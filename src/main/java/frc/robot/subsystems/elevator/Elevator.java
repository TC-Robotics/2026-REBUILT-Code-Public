/* Generated by Phoenix Tuner X */
package frc.robot.subsystems.elevator;

import static edu.wpi.first.units.Units.*;

import java.util.function.DoubleSupplier;
import java.util.function.Supplier;

import org.littletonrobotics.junction.AutoLogOutput;
import org.littletonrobotics.junction.Logger;
import org.littletonrobotics.junction.mechanism.LoggedMechanism2d;
import org.littletonrobotics.junction.mechanism.LoggedMechanismLigament2d;

import com.ctre.phoenix6.BaseStatusSignal;
import com.ctre.phoenix6.CANBus;
import com.ctre.phoenix6.StatusSignal;
import com.ctre.phoenix6.Utils;
import com.ctre.phoenix6.configs.CurrentLimitsConfigs;
import com.ctre.phoenix6.configs.MotorOutputConfigs;
import com.ctre.phoenix6.configs.TalonFXConfiguration;
import com.ctre.phoenix6.controls.DutyCycleOut;
import com.ctre.phoenix6.controls.Follower;
import com.ctre.phoenix6.controls.MotionMagicExpoTorqueCurrentFOC;
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.signals.GravityTypeValue;
import com.ctre.phoenix6.signals.InvertedValue;
import com.ctre.phoenix6.signals.MotorAlignmentValue;
import com.ctre.phoenix6.signals.NeutralModeValue;
import com.ctre.phoenix6.sim.ChassisReference;

import edu.wpi.first.math.system.plant.DCMotor;
import edu.wpi.first.units.measure.*;
import edu.wpi.first.wpilibj.Notifier;
import edu.wpi.first.wpilibj.RobotController;
import edu.wpi.first.wpilibj.simulation.ElevatorSim;
import edu.wpi.first.wpilibj.smartdashboard.Mechanism2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismLigament2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj2.command.button.Trigger;

public class Elevator extends SubsystemBase {

        private final ElevatorIO io;
        private final ElevatorIOInputsAutoLogged inputs = new ElevatorIOInputsAutoLogged();

        /** Position setpoints for the elevator. */
        public enum Setpoint {
                Ground(Rotations.of(0)),
                MidScore(Meters.of(1)),
                HighScore(Meters.of(1.5));

                /** The position target of the setpoint in angular units. */
                public final Angle target;
                /** The position target of the setpoint in linear units. */
                public final Distance targetDist;

                private Setpoint(Angle target) {
                        this.target = target;
                        this.targetDist = ElevatorConstants.kDrumRadius.times(target.in(Radians));
                }

                private Setpoint(Distance target) {
                        this.target = Radians.of(target.div(ElevatorConstants.kDrumRadius).magnitude());
                        this.targetDist = target;
                }
        }

        /** Trigger to detect when the elevator drives into a hard stop. */
        public final Trigger isHardStop = new Trigger(() -> {
                return inputs.angularVelocityRotationsPerSecond < 1 &&
                                inputs.currentAmps > 10;
        }).debounce(0.1);

        /* Mechanism2d visualization of the elevator */
        @AutoLogOutput
        private final LoggedMechanism2d mech2d = new LoggedMechanism2d(1, ElevatorConstants.kMaxHeight.in(Meters));
        private final LoggedMechanismLigament2d leaderMotorMech2d = mech2d.getRoot("leaderMotor Root", 0.500, 0)
                        .append(new LoggedMechanismLigament2d("leaderMotor", ElevatorConstants.kMinHeight.in(Meters),
                                        90));

        public Elevator(ElevatorIO io) {
                this.io = io;
                Logger.processInputs("Elevator", inputs);
                /* set the default command to neutral output */
                setDefaultCommand(manualDrive(() -> 0.0));
                /* alternatively, the default command can hold position */
                // setDefaultCommand(holdPosition());

        }

        /**
         * Holds the elevator at the current position using PID.
         *
         * @return Command to run
         */
        public Command holdPosition() {
                return runOnce(() -> io.setPosition(inputs.positionRotations));
        }

        /**
         * Drives the elevator to the provided position setpoint.
         *
         * @param setpoint Function returning the setpoint to apply
         * @return Command to run
         */
        public Command goToSetpoint(Supplier<Setpoint> setpoint) {
                return run(() -> {
                        io.setPosition(setpoint.get().targetDist.in(Meter));
                });
        }

        /**
         * Manually drives the elevator with the provided duty cycle output.
         *
         * @param manualOutput Function returning the duty cycle to apply
         * @return Command to run
         */
        public Command manualDrive(DoubleSupplier manualOutput) {
                return run(() -> {
                        io.manualDrive(manualOutput.getAsDouble());
                });
        }

        /**
         * Recalibrates the elevator zero point. This slowly drives the elevator
         * down until we see a drop in velocity and a spike in stator current,
         * indicating that we've hit a hard stop.
         *
         * @return Command to run
         */
        public Command calibrateZero() {
                return run(() -> {
                        io.calibrateDrive();
                })
                                .until(isHardStop)
                                .andThen(
                                                manualDrive(() -> 0.0).withTimeout(0.25)
                                                                .finallyDo(() -> {
                                                                        io.zero();
                                                                }));
        }

        @Override
        public void periodic() {
                io.updateInputs(inputs);

                leaderMotorMech2d.setLength(
                                inputs.positionRotations * ElevatorConstants.kDrumRadius.in(Meters) * 2
                                                * Math.PI);
        }
}